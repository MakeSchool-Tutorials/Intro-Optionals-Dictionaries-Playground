/*:
 ![Make School Banner](./swift_banner.png)
 ## Optionalsのメソッドを呼び出し
 
  オプショナル型の値にメソッドを直接呼び出すことはできません。if-letを使用してメソッドを値にバインドするか、メソッドの呼び出し時にオプショナル型のアンラップを強制する必要があります。オプショナル型でメソッドを直接呼び出すとコンパイルタイムエラーになるので、コードはコンパイルを永久に完了しません！
 
 これを実証するため、下にシンプルなクラスを作成しました。
 
 */

class Secret {
    var message: String
    
    init(message: String) {
        self.message = message
    }
    
    func shareMessage() {
        print("私の秘密は: '\(message)'.")
    }
}

var first: Secret? = Secret(message: "if-letsとともにオプショナルバインディングを使用するのはいいアイデアですね！")
var second: Secret? = Secret(message: "nilのためにオプショナルをチェックすることを忘れないでください。")
var third: Secret? = Secret(message: "オプショナルチェイニングも素晴らしいですね。")
var fourth: Secret? = Secret(message: "私は面倒くさがりで、コードがクラッシュしても構わないので、nilのためにアンラップを強制して、絶対にチェックしません！")
fourth = nil // これはバッドプラクティスです。その秘密をなくしましょう！

/*:
 
 これらはすべて`Secret?`型なので、単純に`shareMessage()`を呼び出すことはできません。オプショナル型の`Secret`なので、特別な処理をする必要があります。
 
 */

if let first = first {
    first.shareMessage()
}

/*:
 
 これはシンプルなメソッドの呼び出しなのに、構文は結構大変ですね ... もっと良い方法があるはずです！
 
 ## オプションの連鎖
 
 ですが私たちはプログラマー。ルールにどうにか対処できないかと取り組むのが好きです。「オプショナルチェイニング」というテクニックを使用すれば、オプショナル型でメソッドを直接呼び出せます。チェイニングは、オプショナル型でメソッドを呼び出すためのテクニックで、オプショナル型に値が含まれる場合はメソッドを呼び出し、含まれない場合は何も実行しません。チェイニングを実行するには、変数名とドット、括弧、またはそれに続くブラケットの間に疑問符を置きます。
 */

second?.shareMessage()

/*:
 
 `second`という名前の後に「?」を付けると、プログラムは`shareMessage`の呼び出しを試みる前に、変数が`nil`であるか否かをチェックします。`nil`の場合は何も実行されません。値が含まれていると、メソッドが呼び出されます！
 
 - experiment: オプショナルチェイニングを使用して、`shareMessage`を`third`および`fourth`で呼び出してください。何が起こりますか？
 */



/*:
 
 では、`Secret?`の`message`プロパティにアクセスし、変数に保存してみるとどうなるでしょうか？ その際にオプショナルチェイニングを使ってみましょう。
 
 - experiment: オプショナルチェイニングを使用して`message`を`second`から直接出力してみてください（`shareMessage`は呼び出さないでください）。
 
 */



/*:
 
 ほら、オプショナル型が出力されましたね！ オプショナルチェイニングを使用すると、プロパティとメソッドは実行されない可能性があるため、オプショナル型を返します。
 
 - callout(課題): オプショナルバインディングとオプショナルチェイニングを併用し、`third`の`message`プロパティだけをバインドして出力してください。
 
 */



/*:
 [前へ](@previous) | [次へ](@next)
 */
