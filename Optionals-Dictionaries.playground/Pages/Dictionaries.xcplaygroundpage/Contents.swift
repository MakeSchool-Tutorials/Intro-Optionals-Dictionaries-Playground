/*:
 ![Make School Banner](./swift_banner.png)
 # ディクショナリ
 
  `Dictionary`型は実世界の辞書とよく似ています。複数の値を保存可能なコレクション型で、各値はキーから一意に関連付けられています。実世界の辞書では、キーは単語で、値が定義になります。単語の定義を知りたければ、単語そのもの(キー)を使用して、定義(値)を参照します。`Dictionary`も同じ方法で機能します！
 
 ## ディクショナリの作成
 
 早速新しい`Dictionary`変数を定義しましょう。
 
 */
var cities: [String: String] = ["ニューヨーク": "アメリカ合衆国", "パリ": "フランス", "ロンドン": "イギリス"]
/*:
 
 面白いですよね？ `Dictionary`型の宣言は、`Array`の宣言に似ていますが、一つだけ小さな違いがあります。`Array`では、データの型のみ保存するので`String`の`Array`は`[String]`型で宣言されます。`Dictionary`ではキーと値があるので2つの型が必要です！キー型が最初で、次にコロン`:`、そして値型と続きます。`cities`の`Dictionary`には`String`キーと`String`値があります。
 
 キーと値のペア(実世界の辞書の単語と定義のペア)は、それぞれカンマで区切られます。
 
 - callout(課題): 現実の辞書では単語がキー、定義が値だとすると、`cities`ディクショナリのキーは何で、Swiftのどの型が使用されていますか？`cities`ディクショナリの値は何で、Swiftのどの型が使用されていますか？
 
 - callout(解答): キーは`String`型の都市で、値は`String`型の国です！
 
    ディクショナリの型はキーの型と値の型の両方に依存します。ディクショナリ型を宣言する構文は`[<キーの型>: <値の型>]`です。

 ## ディクショナリを調べる
 
 キーと値のペアの数を取得するには、配列の場合のように`count`プロパティが使えます。`isEmpty`も同じように機能し、配列の場合のように`Bool`を返します。
 
 */
if cities.isEmpty {
    print("都市がありません！")
} else {
    print("ディクショナリは \(cities.count) の項目を含んでいます。")
    print("項目は \(cities)です。")
}
/*:
 
 ## ディクショナリに項目を追加する
 
 ディクショナリに次のように新しい項目を追加できます。
 
 */
cities["サンフランシスコ"] = "USA"
print("ディクショナリは今 \(cities)を含んでいます。")
/*:
 
 配列に含まれる値を更新するときに似ていますが、インデックス番号を角括弧の中に入れる代わりにキーを入れます。
 
 ## 値の更新
 
 さて、ニューヨークの国を`"アメリカ合衆国"`としましたが、サンフランシスコの国は`"USA"`としました。ちょっと一貫性に欠けていますね！直してみましょう。
 
 設定したときと同じようにキーの値も変更できます。
 
 */
cities["サンフランシスコ"] = "アメリカ合衆国"
print("今ディクショナリは一貫性があります。\(cities)を含んでいます。")
/*:
 
 ## ディクショナリから値を得る
 
 - callout(課題): キーを渡して値を求めたら、ディクショナリはどのような型を返すでしょうか？
 
 - callout(解答): `String`ではありますが、`String`ではなくて`String?`(オプショナルの`String`)です。なぜこうなるのでしょう？キーがディクショナリにあると保証できません。これはつまり、確実に値を取得できる保証がないことを意味します。キー値のペアが存在する場合は、値が格納された`String?`を取得します。存在しない場合は`nil`が格納された`String?`を取得します！
 
 キーの値を取得しようとすると、キー値のペアが存在しない場合があります。存在しない場合、ディクショナリは`nil`を返します！
 
 配列の要素にアクセスするのと同じようにキーを渡すことで、キーの値を取得できます。
 
 */
var countryForLondon = cities["ロンドン"]
var countryForSydney = cities["シドニー"]
print("ロンドンは \(countryForLondon)にあり、シドニーは \(countryForSydney)にあります。")
/*:
 
 ディクショナリはオプショナルなので、キーと値のペアにアクセスするにはオプショナルバインディングを使うのが一番です!
 
 */
if let country = cities["シドニー"] {
    print("シドニーは \(country)にあります。")
} else {
    print("ディクショナリはシドニーを含んでいません！")
}
/*:
 
 ## 知るべき他の有用なこと
 
 キーと値のペアを削除するにはキーの値を nil に設定します。
 
 */
cities["サンフランシスコ"] = nil
print("サンフランシスコは削除されました。今ディクショナリは\(cities)を含んでいます。")
/*:
 
 新しい空のディクショナリを定義するには、2種類の方法を選択できます。
 
 */
var exampleDictionary = [String: Int]()
//: or
var anotherDictionary: [String: Double] = [:]
/*:
 
  `exampleDictionary`では値の型が`Int`で、「anotherDictionary」では`Double`であることに注意してください。値の型は好きな型に設定できます。キーも好きな型に設定できます。ただし、キーはハッシュ可能でなければなりません。これはディクショナリが実際にどう機能するかに関係しますが、このチュートリアルの対象範囲ではありません。Swiftの基本型はすべてキーとして機能し、カスタム型をキーとして使用する必要はめったにありません。
 
 - callout(重要): 配列とは違い、ディクショナリは順序なしの状態です。これはつまり、値を特定の順序で維持していはいないという意味です。ディクショナリは一意のキーに基づいて値をすばやく参照したい場合に役立ちます。
 
 ディクショナリのすべてのキーについて処理を繰り返すことができます。
 
 */

for key in cities.keys {
    print("\(key) は \(cities[key]!)にあります。")
}

/*:
 
 ディクショナリを空にするには`[:]`に設定します。
 
 */
cities = [:]
//: - note: （メモ)`[:]`は空のディクショナリのリテラルです。空の配列を意味するので、`[]`にすることはできません。
/*:
 
 では、課題に移りましょう。必要に応じてこちらのページを見直してください。
 
 */
/*:
 [前へ](@previous) | [次へ](@next)
 */
